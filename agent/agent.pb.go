// Code generated by protoc-gen-go. DO NOT EDIT.
// source: agent.proto

/*
Package agent is a generated protocol buffer package.

It is generated from these files:
	agent.proto

It has these top-level messages:
	Archive
	Peer
	Message
	WAL
	DeployOptions
	DeployCommand
	Deploy
	DeployCommandRequest
	DeployCommandResult
	Log
	UploadMetadata
	UploadChunk
	UploadResponse
	WatchRequest
	DispatchResponse
	ConnectRequest
	ConnectResponse
	StatusRequest
	StatusResponse
	DeployRequest
	DeployResponse
	ShutdownRequest
	ShutdownResponse
	CancelRequest
	CancelResponse
	DispatchRequest
*/
package agent

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Peer_State int32

const (
	Peer_Node   Peer_State = 0
	Peer_Client Peer_State = 2
	Peer_Gone   Peer_State = 3
)

var Peer_State_name = map[int32]string{
	0: "Node",
	2: "Client",
	3: "Gone",
}
var Peer_State_value = map[string]int32{
	"Node":   0,
	"Client": 2,
	"Gone":   3,
}

func (x Peer_State) String() string {
	return proto.EnumName(Peer_State_name, int32(x))
}
func (Peer_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type Message_Type int32

const (
	Message_PeerEvent           Message_Type = 0
	Message_LogEvent            Message_Type = 1
	Message_DeployCommandEvent  Message_Type = 2
	Message_DeployEvent         Message_Type = 3
	Message_PeersFoundEvent     Message_Type = 4
	Message_PeersCompletedEvent Message_Type = 5
)

var Message_Type_name = map[int32]string{
	0: "PeerEvent",
	1: "LogEvent",
	2: "DeployCommandEvent",
	3: "DeployEvent",
	4: "PeersFoundEvent",
	5: "PeersCompletedEvent",
}
var Message_Type_value = map[string]int32{
	"PeerEvent":           0,
	"LogEvent":            1,
	"DeployCommandEvent":  2,
	"DeployEvent":         3,
	"PeersFoundEvent":     4,
	"PeersCompletedEvent": 5,
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}
func (Message_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type DeployCommand_Command int32

const (
	DeployCommand_Begin  DeployCommand_Command = 0
	DeployCommand_Cancel DeployCommand_Command = 1
	DeployCommand_Done   DeployCommand_Command = 2
	DeployCommand_Failed DeployCommand_Command = 3
)

var DeployCommand_Command_name = map[int32]string{
	0: "Begin",
	1: "Cancel",
	2: "Done",
	3: "Failed",
}
var DeployCommand_Command_value = map[string]int32{
	"Begin":  0,
	"Cancel": 1,
	"Done":   2,
	"Failed": 3,
}

func (x DeployCommand_Command) String() string {
	return proto.EnumName(DeployCommand_Command_name, int32(x))
}
func (DeployCommand_Command) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type Deploy_Stage int32

const (
	Deploy_Failed    Deploy_Stage = 0
	Deploy_Deploying Deploy_Stage = 1
	Deploy_Completed Deploy_Stage = 2
)

var Deploy_Stage_name = map[int32]string{
	0: "Failed",
	1: "Deploying",
	2: "Completed",
}
var Deploy_Stage_value = map[string]int32{
	"Failed":    0,
	"Deploying": 1,
	"Completed": 2,
}

func (x Deploy_Stage) String() string {
	return proto.EnumName(Deploy_Stage_name, int32(x))
}
func (Deploy_Stage) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type Archive struct {
	DeploymentID []byte `protobuf:"bytes,1,opt,name=deploymentID,proto3" json:"deploymentID,omitempty"`
	Peer         *Peer  `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Location     string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	Checksum     []byte `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	Ts           int64  `protobuf:"varint,5,opt,name=ts" json:"ts,omitempty"`
	Initiator    string `protobuf:"bytes,6,opt,name=initiator" json:"initiator,omitempty"`
}

func (m *Archive) Reset()                    { *m = Archive{} }
func (m *Archive) String() string            { return proto.CompactTextString(m) }
func (*Archive) ProtoMessage()               {}
func (*Archive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Archive) GetDeploymentID() []byte {
	if m != nil {
		return m.DeploymentID
	}
	return nil
}

func (m *Archive) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Archive) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Archive) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *Archive) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Archive) GetInitiator() string {
	if m != nil {
		return m.Initiator
	}
	return ""
}

type Peer struct {
	Status      Peer_State `protobuf:"varint,1,opt,name=Status,enum=agent.Peer_State" json:"Status,omitempty"`
	Ip          string     `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Name        string     `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	RPCPort     uint32     `protobuf:"varint,4,opt,name=RPCPort" json:"RPCPort,omitempty"`
	RaftPort    uint32     `protobuf:"varint,5,opt,name=RaftPort" json:"RaftPort,omitempty"`
	SWIMPort    uint32     `protobuf:"varint,6,opt,name=SWIMPort" json:"SWIMPort,omitempty"`
	TorrentPort uint32     `protobuf:"varint,7,opt,name=TorrentPort" json:"TorrentPort,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Peer) GetStatus() Peer_State {
	if m != nil {
		return m.Status
	}
	return Peer_Node
}

func (m *Peer) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Peer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Peer) GetRPCPort() uint32 {
	if m != nil {
		return m.RPCPort
	}
	return 0
}

func (m *Peer) GetRaftPort() uint32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *Peer) GetSWIMPort() uint32 {
	if m != nil {
		return m.SWIMPort
	}
	return 0
}

func (m *Peer) GetTorrentPort() uint32 {
	if m != nil {
		return m.TorrentPort
	}
	return 0
}

// Represents every message sent between nodes. effectively describes all possible events we may want
// to act upon.
type Message struct {
	Id     string `protobuf:"bytes,9,opt,name=id" json:"id,omitempty"`
	Replay bool   `protobuf:"varint,999,opt,name=replay" json:"replay,omitempty"`
	// Identifies which field is filled in.
	Type Message_Type `protobuf:"varint,1,opt,name=type,enum=agent.Message_Type" json:"type,omitempty"`
	Peer *Peer        `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Ts   int64        `protobuf:"varint,3,opt,name=ts" json:"ts,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*Message_None
	//	*Message_Int
	//	*Message_Log
	//	*Message_DeployCommand
	//	*Message_Deploy
	Event isMessage_Event `protobuf_oneof:"Event"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isMessage_Event interface {
	isMessage_Event()
}

type Message_None struct {
	None bool `protobuf:"varint,4,opt,name=none,oneof"`
}
type Message_Int struct {
	Int int64 `protobuf:"varint,5,opt,name=int,oneof"`
}
type Message_Log struct {
	Log *Log `protobuf:"bytes,6,opt,name=log,oneof"`
}
type Message_DeployCommand struct {
	DeployCommand *DeployCommand `protobuf:"bytes,7,opt,name=deployCommand,oneof"`
}
type Message_Deploy struct {
	Deploy *Deploy `protobuf:"bytes,8,opt,name=deploy,oneof"`
}

func (*Message_None) isMessage_Event()          {}
func (*Message_Int) isMessage_Event()           {}
func (*Message_Log) isMessage_Event()           {}
func (*Message_DeployCommand) isMessage_Event() {}
func (*Message_Deploy) isMessage_Event()        {}

func (m *Message) GetEvent() isMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Message) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Message) GetReplay() bool {
	if m != nil {
		return m.Replay
	}
	return false
}

func (m *Message) GetType() Message_Type {
	if m != nil {
		return m.Type
	}
	return Message_PeerEvent
}

func (m *Message) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Message) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Message) GetNone() bool {
	if x, ok := m.GetEvent().(*Message_None); ok {
		return x.None
	}
	return false
}

func (m *Message) GetInt() int64 {
	if x, ok := m.GetEvent().(*Message_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Message) GetLog() *Log {
	if x, ok := m.GetEvent().(*Message_Log); ok {
		return x.Log
	}
	return nil
}

func (m *Message) GetDeployCommand() *DeployCommand {
	if x, ok := m.GetEvent().(*Message_DeployCommand); ok {
		return x.DeployCommand
	}
	return nil
}

func (m *Message) GetDeploy() *Deploy {
	if x, ok := m.GetEvent().(*Message_Deploy); ok {
		return x.Deploy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_None)(nil),
		(*Message_Int)(nil),
		(*Message_Log)(nil),
		(*Message_DeployCommand)(nil),
		(*Message_Deploy)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Message_Int:
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int))
	case *Message_Log:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Log); err != nil {
			return err
		}
	case *Message_DeployCommand:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeployCommand); err != nil {
			return err
		}
	case *Message_Deploy:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deploy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Event has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 4: // Event.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Event = &Message_None{x != 0}
		return true, err
	case 5: // Event.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Event = &Message_Int{int64(x)}
		return true, err
	case 6: // Event.log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Log)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Log{msg}
		return true, err
	case 7: // Event.deployCommand
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeployCommand)
		err := b.DecodeMessage(msg)
		m.Event = &Message_DeployCommand{msg}
		return true, err
	case 8: // Event.deploy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deploy)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Deploy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *Message_Int:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *Message_Log:
		s := proto.Size(x.Log)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_DeployCommand:
		s := proto.Size(x.DeployCommand)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Deploy:
		s := proto.Size(x.Deploy)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Write ahead log
type WAL struct {
	Messages []*Message `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
}

func (m *WAL) Reset()                    { *m = WAL{} }
func (m *WAL) String() string            { return proto.CompactTextString(m) }
func (*WAL) ProtoMessage()               {}
func (*WAL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WAL) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type DeployOptions struct {
	Concurrency       int64 `protobuf:"varint,2,opt,name=concurrency" json:"concurrency,omitempty"`
	Timeout           int64 `protobuf:"varint,3,opt,name=timeout" json:"timeout,omitempty"`
	IgnoreFailures    bool  `protobuf:"varint,4,opt,name=ignoreFailures" json:"ignoreFailures,omitempty"`
	SilenceDeployLogs bool  `protobuf:"varint,5,opt,name=silenceDeployLogs" json:"silenceDeployLogs,omitempty"`
}

func (m *DeployOptions) Reset()                    { *m = DeployOptions{} }
func (m *DeployOptions) String() string            { return proto.CompactTextString(m) }
func (*DeployOptions) ProtoMessage()               {}
func (*DeployOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DeployOptions) GetConcurrency() int64 {
	if m != nil {
		return m.Concurrency
	}
	return 0
}

func (m *DeployOptions) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *DeployOptions) GetIgnoreFailures() bool {
	if m != nil {
		return m.IgnoreFailures
	}
	return false
}

func (m *DeployOptions) GetSilenceDeployLogs() bool {
	if m != nil {
		return m.SilenceDeployLogs
	}
	return false
}

type DeployCommand struct {
	Command DeployCommand_Command `protobuf:"varint,1,opt,name=command,enum=agent.DeployCommand_Command" json:"command,omitempty"`
	Archive *Archive              `protobuf:"bytes,2,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions        `protobuf:"bytes,5,opt,name=options" json:"options,omitempty"`
}

func (m *DeployCommand) Reset()                    { *m = DeployCommand{} }
func (m *DeployCommand) String() string            { return proto.CompactTextString(m) }
func (*DeployCommand) ProtoMessage()               {}
func (*DeployCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DeployCommand) GetCommand() DeployCommand_Command {
	if m != nil {
		return m.Command
	}
	return DeployCommand_Begin
}

func (m *DeployCommand) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *DeployCommand) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type Deploy struct {
	Stage   Deploy_Stage   `protobuf:"varint,1,opt,name=stage,enum=agent.Deploy_Stage" json:"stage,omitempty"`
	Archive *Archive       `protobuf:"bytes,2,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions `protobuf:"bytes,4,opt,name=options" json:"options,omitempty"`
	Error   string         `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *Deploy) Reset()                    { *m = Deploy{} }
func (m *Deploy) String() string            { return proto.CompactTextString(m) }
func (*Deploy) ProtoMessage()               {}
func (*Deploy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Deploy) GetStage() Deploy_Stage {
	if m != nil {
		return m.Stage
	}
	return Deploy_Failed
}

func (m *Deploy) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *Deploy) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Deploy) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type DeployCommandRequest struct {
	Archive *Archive       `protobuf:"bytes,1,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions `protobuf:"bytes,5,opt,name=options" json:"options,omitempty"`
	Peers   []*Peer        `protobuf:"bytes,4,rep,name=peers" json:"peers,omitempty"`
}

func (m *DeployCommandRequest) Reset()                    { *m = DeployCommandRequest{} }
func (m *DeployCommandRequest) String() string            { return proto.CompactTextString(m) }
func (*DeployCommandRequest) ProtoMessage()               {}
func (*DeployCommandRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DeployCommandRequest) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *DeployCommandRequest) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *DeployCommandRequest) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type DeployCommandResult struct {
}

func (m *DeployCommandResult) Reset()                    { *m = DeployCommandResult{} }
func (m *DeployCommandResult) String() string            { return proto.CompactTextString(m) }
func (*DeployCommandResult) ProtoMessage()               {}
func (*DeployCommandResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type Log struct {
	Log string `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Log) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type UploadMetadata struct {
	Bytes     uint64 `protobuf:"varint,1,opt,name=bytes" json:"bytes,omitempty"`
	Initiator string `protobuf:"bytes,2,opt,name=initiator" json:"initiator,omitempty"`
}

func (m *UploadMetadata) Reset()                    { *m = UploadMetadata{} }
func (m *UploadMetadata) String() string            { return proto.CompactTextString(m) }
func (*UploadMetadata) ProtoMessage()               {}
func (*UploadMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UploadMetadata) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *UploadMetadata) GetInitiator() string {
	if m != nil {
		return m.Initiator
	}
	return ""
}

type UploadChunk struct {
	Data     []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Checksum []byte `protobuf:"bytes,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Types that are valid to be assigned to InitialChunkMetadata:
	//	*UploadChunk_None
	//	*UploadChunk_Metadata
	InitialChunkMetadata isUploadChunk_InitialChunkMetadata `protobuf_oneof:"initialChunkMetadata"`
}

func (m *UploadChunk) Reset()                    { *m = UploadChunk{} }
func (m *UploadChunk) String() string            { return proto.CompactTextString(m) }
func (*UploadChunk) ProtoMessage()               {}
func (*UploadChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isUploadChunk_InitialChunkMetadata interface {
	isUploadChunk_InitialChunkMetadata()
}

type UploadChunk_None struct {
	None bool `protobuf:"varint,3,opt,name=none,oneof"`
}
type UploadChunk_Metadata struct {
	Metadata *UploadMetadata `protobuf:"bytes,4,opt,name=metadata,oneof"`
}

func (*UploadChunk_None) isUploadChunk_InitialChunkMetadata()     {}
func (*UploadChunk_Metadata) isUploadChunk_InitialChunkMetadata() {}

func (m *UploadChunk) GetInitialChunkMetadata() isUploadChunk_InitialChunkMetadata {
	if m != nil {
		return m.InitialChunkMetadata
	}
	return nil
}

func (m *UploadChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UploadChunk) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *UploadChunk) GetNone() bool {
	if x, ok := m.GetInitialChunkMetadata().(*UploadChunk_None); ok {
		return x.None
	}
	return false
}

func (m *UploadChunk) GetMetadata() *UploadMetadata {
	if x, ok := m.GetInitialChunkMetadata().(*UploadChunk_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UploadChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UploadChunk_OneofMarshaler, _UploadChunk_OneofUnmarshaler, _UploadChunk_OneofSizer, []interface{}{
		(*UploadChunk_None)(nil),
		(*UploadChunk_Metadata)(nil),
	}
}

func _UploadChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UploadChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *UploadChunk_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *UploadChunk_Metadata:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UploadChunk.InitialChunkMetadata has unexpected type %T", x)
	}
	return nil
}

func _UploadChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UploadChunk)
	switch tag {
	case 3: // initialChunkMetadata.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.InitialChunkMetadata = &UploadChunk_None{x != 0}
		return true, err
	case 4: // initialChunkMetadata.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadMetadata)
		err := b.DecodeMessage(msg)
		m.InitialChunkMetadata = &UploadChunk_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _UploadChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UploadChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *UploadChunk_None:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *UploadChunk_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type UploadResponse struct {
	Archive *Archive `protobuf:"bytes,1,opt,name=archive" json:"archive,omitempty"`
}

func (m *UploadResponse) Reset()                    { *m = UploadResponse{} }
func (m *UploadResponse) String() string            { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()               {}
func (*UploadResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UploadResponse) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

type WatchRequest struct {
}

func (m *WatchRequest) Reset()                    { *m = WatchRequest{} }
func (m *WatchRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()               {}
func (*WatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type DispatchResponse struct {
}

func (m *DispatchResponse) Reset()                    { *m = DispatchResponse{} }
func (m *DispatchResponse) String() string            { return proto.CompactTextString(m) }
func (*DispatchResponse) ProtoMessage()               {}
func (*DispatchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type ConnectRequest struct {
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type ConnectResponse struct {
	Secret []byte  `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	Quorum []*Peer `protobuf:"bytes,2,rep,name=quorum" json:"quorum,omitempty"`
}

func (m *ConnectResponse) Reset()                    { *m = ConnectResponse{} }
func (m *ConnectResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectResponse) ProtoMessage()               {}
func (*ConnectResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ConnectResponse) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *ConnectResponse) GetQuorum() []*Peer {
	if m != nil {
		return m.Quorum
	}
	return nil
}

type StatusRequest struct {
}

func (m *StatusRequest) Reset()                    { *m = StatusRequest{} }
func (m *StatusRequest) String() string            { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()               {}
func (*StatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type StatusResponse struct {
	Peer        *Peer     `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	Deployments []*Deploy `protobuf:"bytes,4,rep,name=deployments" json:"deployments,omitempty"`
}

func (m *StatusResponse) Reset()                    { *m = StatusResponse{} }
func (m *StatusResponse) String() string            { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()               {}
func (*StatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *StatusResponse) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *StatusResponse) GetDeployments() []*Deploy {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type DeployRequest struct {
	Archive *Archive       `protobuf:"bytes,1,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions `protobuf:"bytes,2,opt,name=options" json:"options,omitempty"`
}

func (m *DeployRequest) Reset()                    { *m = DeployRequest{} }
func (m *DeployRequest) String() string            { return proto.CompactTextString(m) }
func (*DeployRequest) ProtoMessage()               {}
func (*DeployRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DeployRequest) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *DeployRequest) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type DeployResponse struct {
	Deploy *Deploy `protobuf:"bytes,1,opt,name=deploy" json:"deploy,omitempty"`
}

func (m *DeployResponse) Reset()                    { *m = DeployResponse{} }
func (m *DeployResponse) String() string            { return proto.CompactTextString(m) }
func (*DeployResponse) ProtoMessage()               {}
func (*DeployResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DeployResponse) GetDeploy() *Deploy {
	if m != nil {
		return m.Deploy
	}
	return nil
}

type ShutdownRequest struct {
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type ShutdownResponse struct {
}

func (m *ShutdownResponse) Reset()                    { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()               {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

type CancelRequest struct {
}

func (m *CancelRequest) Reset()                    { *m = CancelRequest{} }
func (m *CancelRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelRequest) ProtoMessage()               {}
func (*CancelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

type CancelResponse struct {
}

func (m *CancelResponse) Reset()                    { *m = CancelResponse{} }
func (m *CancelResponse) String() string            { return proto.CompactTextString(m) }
func (*CancelResponse) ProtoMessage()               {}
func (*CancelResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

type DispatchRequest struct {
	Messages []*Message `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
}

func (m *DispatchRequest) Reset()                    { *m = DispatchRequest{} }
func (m *DispatchRequest) String() string            { return proto.CompactTextString(m) }
func (*DispatchRequest) ProtoMessage()               {}
func (*DispatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *DispatchRequest) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

func init() {
	proto.RegisterType((*Archive)(nil), "agent.Archive")
	proto.RegisterType((*Peer)(nil), "agent.Peer")
	proto.RegisterType((*Message)(nil), "agent.Message")
	proto.RegisterType((*WAL)(nil), "agent.WAL")
	proto.RegisterType((*DeployOptions)(nil), "agent.DeployOptions")
	proto.RegisterType((*DeployCommand)(nil), "agent.DeployCommand")
	proto.RegisterType((*Deploy)(nil), "agent.Deploy")
	proto.RegisterType((*DeployCommandRequest)(nil), "agent.DeployCommandRequest")
	proto.RegisterType((*DeployCommandResult)(nil), "agent.DeployCommandResult")
	proto.RegisterType((*Log)(nil), "agent.Log")
	proto.RegisterType((*UploadMetadata)(nil), "agent.UploadMetadata")
	proto.RegisterType((*UploadChunk)(nil), "agent.UploadChunk")
	proto.RegisterType((*UploadResponse)(nil), "agent.UploadResponse")
	proto.RegisterType((*WatchRequest)(nil), "agent.WatchRequest")
	proto.RegisterType((*DispatchResponse)(nil), "agent.DispatchResponse")
	proto.RegisterType((*ConnectRequest)(nil), "agent.ConnectRequest")
	proto.RegisterType((*ConnectResponse)(nil), "agent.ConnectResponse")
	proto.RegisterType((*StatusRequest)(nil), "agent.StatusRequest")
	proto.RegisterType((*StatusResponse)(nil), "agent.StatusResponse")
	proto.RegisterType((*DeployRequest)(nil), "agent.DeployRequest")
	proto.RegisterType((*DeployResponse)(nil), "agent.DeployResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "agent.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "agent.ShutdownResponse")
	proto.RegisterType((*CancelRequest)(nil), "agent.CancelRequest")
	proto.RegisterType((*CancelResponse)(nil), "agent.CancelResponse")
	proto.RegisterType((*DispatchRequest)(nil), "agent.DispatchRequest")
	proto.RegisterEnum("agent.Peer_State", Peer_State_name, Peer_State_value)
	proto.RegisterEnum("agent.Message_Type", Message_Type_name, Message_Type_value)
	proto.RegisterEnum("agent.DeployCommand_Command", DeployCommand_Command_name, DeployCommand_Command_value)
	proto.RegisterEnum("agent.Deploy_Stage", Deploy_Stage_name, Deploy_Stage_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Quorum service

type QuorumClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (Quorum_UploadClient, error)
	Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Quorum_WatchClient, error)
	Dispatch(ctx context.Context, in *DispatchRequest, opts ...grpc.CallOption) (*DispatchResponse, error)
	Deploy(ctx context.Context, in *DeployCommandRequest, opts ...grpc.CallOption) (*DeployCommandResult, error)
}

type quorumClient struct {
	cc *grpc.ClientConn
}

func NewQuorumClient(cc *grpc.ClientConn) QuorumClient {
	return &quorumClient{cc}
}

func (c *quorumClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Quorum_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[0], c.cc, "/agent.Quorum/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumUploadClient{stream}
	return x, nil
}

type Quorum_UploadClient interface {
	Send(*UploadChunk) error
	CloseAndRecv() (*UploadResponse, error)
	grpc.ClientStream
}

type quorumUploadClient struct {
	grpc.ClientStream
}

func (x *quorumUploadClient) Send(m *UploadChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *quorumUploadClient) CloseAndRecv() (*UploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quorumClient) Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Quorum_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[1], c.cc, "/agent.Quorum/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Quorum_WatchClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type quorumWatchClient struct {
	grpc.ClientStream
}

func (x *quorumWatchClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quorumClient) Dispatch(ctx context.Context, in *DispatchRequest, opts ...grpc.CallOption) (*DispatchResponse, error) {
	out := new(DispatchResponse)
	err := grpc.Invoke(ctx, "/agent.Quorum/Dispatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quorumClient) Deploy(ctx context.Context, in *DeployCommandRequest, opts ...grpc.CallOption) (*DeployCommandResult, error) {
	out := new(DeployCommandResult)
	err := grpc.Invoke(ctx, "/agent.Quorum/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Quorum service

type QuorumServer interface {
	Upload(Quorum_UploadServer) error
	Watch(*WatchRequest, Quorum_WatchServer) error
	Dispatch(context.Context, *DispatchRequest) (*DispatchResponse, error)
	Deploy(context.Context, *DeployCommandRequest) (*DeployCommandResult, error)
}

func RegisterQuorumServer(s *grpc.Server, srv QuorumServer) {
	s.RegisterService(&_Quorum_serviceDesc, srv)
}

func _Quorum_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QuorumServer).Upload(&quorumUploadServer{stream})
}

type Quorum_UploadServer interface {
	SendAndClose(*UploadResponse) error
	Recv() (*UploadChunk, error)
	grpc.ServerStream
}

type quorumUploadServer struct {
	grpc.ServerStream
}

func (x *quorumUploadServer) SendAndClose(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *quorumUploadServer) Recv() (*UploadChunk, error) {
	m := new(UploadChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Quorum_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuorumServer).Watch(m, &quorumWatchServer{stream})
}

type Quorum_WatchServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type quorumWatchServer struct {
	grpc.ServerStream
}

func (x *quorumWatchServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Quorum_Dispatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DispatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuorumServer).Dispatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Quorum/Dispatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuorumServer).Dispatch(ctx, req.(*DispatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Quorum_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuorumServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Quorum/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuorumServer).Deploy(ctx, req.(*DeployCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Quorum_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Quorum",
	HandlerType: (*QuorumServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dispatch",
			Handler:    _Quorum_Dispatch_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Quorum_Deploy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Quorum_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Watch",
			Handler:       _Quorum_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent.proto",
}

// Client API for Agent service

type AgentClient interface {
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	Deploy(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error)
	Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*CancelResponse, error)
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Deploy(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error) {
	out := new(DeployResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*CancelResponse, error) {
	out := new(CancelResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Cancel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Agent service

type AgentServer interface {
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	Info(context.Context, *StatusRequest) (*StatusResponse, error)
	Deploy(context.Context, *DeployRequest) (*DeployResponse, error)
	Cancel(context.Context, *CancelRequest) (*CancelResponse, error)
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Info(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Deploy(ctx, req.(*DeployRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Cancel(ctx, req.(*CancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Agent_Connect_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Agent_Info_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Agent_Deploy_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _Agent_Cancel_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Agent_Shutdown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "agent.proto",
}

// Client API for Observer service

type ObserverClient interface {
	Dispatch(ctx context.Context, in *DispatchRequest, opts ...grpc.CallOption) (*DispatchResponse, error)
}

type observerClient struct {
	cc *grpc.ClientConn
}

func NewObserverClient(cc *grpc.ClientConn) ObserverClient {
	return &observerClient{cc}
}

func (c *observerClient) Dispatch(ctx context.Context, in *DispatchRequest, opts ...grpc.CallOption) (*DispatchResponse, error) {
	out := new(DispatchResponse)
	err := grpc.Invoke(ctx, "/agent.Observer/Dispatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Observer service

type ObserverServer interface {
	Dispatch(context.Context, *DispatchRequest) (*DispatchResponse, error)
}

func RegisterObserverServer(s *grpc.Server, srv ObserverServer) {
	s.RegisterService(&_Observer_serviceDesc, srv)
}

func _Observer_Dispatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DispatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObserverServer).Dispatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Observer/Dispatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObserverServer).Dispatch(ctx, req.(*DispatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Observer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Observer",
	HandlerType: (*ObserverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dispatch",
			Handler:    _Observer_Dispatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "agent.proto",
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1250 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdb, 0x6e, 0x1c, 0x45,
	0x13, 0x9e, 0xd9, 0xd9, 0x93, 0x6b, 0xbd, 0x87, 0x94, 0x1d, 0x7b, 0xe5, 0x3f, 0xfa, 0x31, 0x8d,
	0x20, 0x1b, 0x84, 0x4c, 0xb2, 0x11, 0x89, 0x14, 0x91, 0x8b, 0x64, 0x4d, 0xb0, 0x25, 0xe7, 0x40,
	0x27, 0x28, 0xd7, 0xe3, 0xd9, 0xce, 0x78, 0x94, 0xd9, 0xee, 0xc9, 0x4c, 0x6f, 0x90, 0x79, 0x0d,
	0x5e, 0x00, 0xae, 0xb9, 0xe5, 0x09, 0x78, 0x08, 0x24, 0x9e, 0x80, 0x7b, 0x6e, 0xb8, 0x45, 0x7d,
	0x1a, 0xef, 0x8c, 0x8d, 0x30, 0x84, 0x2b, 0x4f, 0x1d, 0xba, 0xba, 0xaa, 0xbe, 0xaf, 0xab, 0xbc,
	0xd0, 0x0b, 0x63, 0xc6, 0xe5, 0x5e, 0x96, 0x0b, 0x29, 0xb0, 0xa5, 0x05, 0xf2, 0x93, 0x0f, 0x9d,
	0x07, 0x79, 0x74, 0x92, 0xbc, 0x65, 0x48, 0x60, 0x7d, 0xce, 0xb2, 0x54, 0x9c, 0x2e, 0x18, 0x97,
	0x87, 0xfb, 0x63, 0x7f, 0xd7, 0x9f, 0xac, 0xd3, 0x8a, 0x0e, 0xdf, 0x83, 0x66, 0xc6, 0x58, 0x3e,
	0x6e, 0xec, 0xfa, 0x93, 0xde, 0xb4, 0xb7, 0x67, 0x42, 0x3e, 0x63, 0x2c, 0xa7, 0xda, 0x80, 0x3b,
	0xd0, 0x4d, 0x45, 0x14, 0xca, 0x44, 0xf0, 0x71, 0xb0, 0xeb, 0x4f, 0xd6, 0x68, 0x29, 0x2b, 0x5b,
	0x74, 0xc2, 0xa2, 0xd7, 0xc5, 0x72, 0x31, 0x6e, 0xea, 0xe0, 0xa5, 0x8c, 0x03, 0x68, 0xc8, 0x62,
	0xdc, 0xda, 0xf5, 0x27, 0x01, 0x6d, 0xc8, 0x02, 0xaf, 0xc1, 0x5a, 0xc2, 0x13, 0x99, 0x84, 0x52,
	0xe4, 0xe3, 0xb6, 0x0e, 0x74, 0xa6, 0x20, 0xbf, 0xfb, 0xd0, 0x54, 0x97, 0xe2, 0x0d, 0x68, 0x3f,
	0x97, 0xa1, 0x5c, 0x16, 0x3a, 0xdb, 0xc1, 0xf4, 0xca, 0x4a, 0x46, 0x7b, 0xca, 0xc2, 0xa8, 0x75,
	0x50, 0x37, 0x24, 0x99, 0x4e, 0x7c, 0x8d, 0x36, 0x92, 0x0c, 0x11, 0x9a, 0x3c, 0x5c, 0x30, 0x9b,
	0xa5, 0xfe, 0xc6, 0x31, 0x74, 0xe8, 0xb3, 0xd9, 0x33, 0x91, 0x4b, 0x9d, 0x60, 0x9f, 0x3a, 0x51,
	0xe5, 0x4e, 0xc3, 0x57, 0x52, 0x9b, 0x5a, 0xda, 0x54, 0xca, 0xca, 0xf6, 0xfc, 0xe5, 0xe1, 0x63,
	0x6d, 0x6b, 0x1b, 0x9b, 0x93, 0x71, 0x17, 0x7a, 0x2f, 0x44, 0x9e, 0x33, 0x6e, 0x8e, 0x76, 0xb4,
	0x79, 0x55, 0x45, 0xae, 0x43, 0x4b, 0x27, 0x8a, 0x5d, 0x68, 0x3e, 0x11, 0x73, 0x36, 0xf2, 0x10,
	0xa0, 0x3d, 0x4b, 0x13, 0xc6, 0xe5, 0xa8, 0xa1, 0xb4, 0x5f, 0x0a, 0xce, 0x46, 0x01, 0xf9, 0x39,
	0x80, 0xce, 0x63, 0x56, 0x14, 0x61, 0xcc, 0x74, 0x31, 0xf3, 0xf1, 0x9a, 0x2d, 0x66, 0x8e, 0xdb,
	0xd0, 0xce, 0x59, 0x96, 0x86, 0xa7, 0xe3, 0xdf, 0xd4, 0x15, 0x5d, 0x6a, 0x45, 0xbc, 0x0e, 0x4d,
	0x79, 0x9a, 0x31, 0xdb, 0x9e, 0x0d, 0xdb, 0x1e, 0x1b, 0x66, 0xef, 0xc5, 0x69, 0xc6, 0xa8, 0x76,
	0xf8, 0x7b, 0x64, 0x0d, 0x42, 0x41, 0x89, 0xd0, 0x26, 0x34, 0xb9, 0xe0, 0x4c, 0x37, 0xaa, 0x7b,
	0xe0, 0x51, 0x2d, 0x21, 0x42, 0x90, 0x70, 0xd3, 0xa2, 0xe0, 0xc0, 0xa3, 0x4a, 0xc0, 0xff, 0x43,
	0x90, 0x8a, 0x58, 0xb7, 0xa6, 0x37, 0x05, 0x1b, 0xf9, 0x48, 0xc4, 0xca, 0x9e, 0x8a, 0x18, 0x3f,
	0x87, 0xbe, 0x21, 0xd9, 0x4c, 0x2c, 0x16, 0x21, 0x9f, 0xeb, 0x2e, 0xf5, 0xa6, 0x9b, 0xd6, 0x73,
	0x7f, 0xd5, 0x76, 0xe0, 0xd1, 0xaa, 0x33, 0x5e, 0x87, 0xb6, 0x51, 0x8c, 0xbb, 0xfa, 0x58, 0xbf,
	0x72, 0xec, 0xc0, 0xa3, 0xd6, 0x4c, 0xbe, 0x85, 0xa6, 0xaa, 0x17, 0xfb, 0xb0, 0xa6, 0xca, 0xfa,
	0xe2, 0xad, 0x6a, 0xb0, 0x87, 0xeb, 0xd0, 0x3d, 0x12, 0xb1, 0x91, 0x7c, 0xdc, 0x02, 0xac, 0xdc,
	0x67, 0xf4, 0x0d, 0x1c, 0x42, 0xcf, 0xe8, 0x8d, 0x22, 0xc0, 0x0d, 0x18, 0xaa, 0x28, 0xc5, 0x23,
	0xb1, 0x74, 0x5e, 0x4d, 0xdc, 0x86, 0x0d, 0xad, 0x9c, 0x89, 0x45, 0x96, 0x32, 0xc9, 0xac, 0xa1,
	0xf5, 0xb0, 0x03, 0x2d, 0xfd, 0x49, 0x6e, 0x41, 0xf0, 0xf2, 0xc1, 0x11, 0x7e, 0x0c, 0xdd, 0x85,
	0xc1, 0x40, 0x31, 0x37, 0x98, 0xf4, 0xa6, 0x83, 0x2a, 0x34, 0xb4, 0xb4, 0x93, 0x1f, 0x7c, 0xe8,
	0x9b, 0xbb, 0x9f, 0x66, 0xea, 0x1d, 0x15, 0x8a, 0x54, 0x91, 0xe0, 0xd1, 0x52, 0x91, 0x28, 0x3a,
	0xd5, 0x90, 0x05, 0x74, 0x55, 0xa5, 0x88, 0x2c, 0x93, 0x05, 0x13, 0x4b, 0x69, 0x11, 0x73, 0x22,
	0x7e, 0x04, 0x83, 0x24, 0xe6, 0x22, 0x67, 0x8f, 0xc2, 0x24, 0x5d, 0xe6, 0xac, 0x30, 0x00, 0xd2,
	0x9a, 0x16, 0x3f, 0x81, 0x2b, 0x45, 0x92, 0x32, 0x1e, 0x31, 0x73, 0xf7, 0x91, 0x88, 0xcd, 0xfb,
	0xec, 0xd2, 0xf3, 0x06, 0xf2, 0x6b, 0x99, 0xa3, 0x83, 0xe5, 0x0e, 0x74, 0x22, 0x0b, 0xa7, 0xe1,
	0xde, 0xb5, 0x8b, 0xe0, 0xdc, 0xb3, 0x7f, 0xa9, 0x73, 0xc6, 0x09, 0x74, 0x42, 0x33, 0x90, 0x2c,
	0x15, 0x5d, 0x63, 0xec, 0x98, 0xa2, 0xce, 0x8c, 0x7b, 0xd0, 0x11, 0xa6, 0x21, 0x3a, 0xaf, 0x3a,
	0x61, 0x6c, 0xb3, 0xa8, 0x73, 0x22, 0x77, 0xa0, 0xe3, 0x92, 0x5b, 0x83, 0xd6, 0x43, 0x16, 0x27,
	0xdc, 0xbe, 0xb5, 0x90, 0x47, 0x2c, 0x1d, 0xf9, 0xea, 0xad, 0xed, 0xab, 0xb7, 0xd6, 0x50, 0x5a,
	0xd5, 0x09, 0x36, 0x1f, 0x05, 0xe4, 0x17, 0x1f, 0xda, 0x26, 0x24, 0xde, 0x80, 0x56, 0x21, 0xc3,
	0xb8, 0xfe, 0x9c, 0x8c, 0x55, 0xcd, 0x9b, 0x98, 0x51, 0xe3, 0xf1, 0xef, 0xea, 0x68, 0x5e, 0xa2,
	0x0e, 0xdc, 0x84, 0x16, 0xcb, 0x73, 0x91, 0xdb, 0xc9, 0x65, 0x04, 0x72, 0x4b, 0x8f, 0x91, 0x98,
	0xad, 0xa4, 0xee, 0x29, 0xaa, 0x9b, 0x20, 0x09, 0x8f, 0x47, 0xbe, 0x12, 0x4b, 0x66, 0x8e, 0x1a,
	0xe4, 0x3b, 0x1f, 0x36, 0x2b, 0x68, 0x50, 0xf6, 0x66, 0xc9, 0x0a, 0xb9, 0x9a, 0xbb, 0xff, 0x9f,
	0x62, 0x80, 0xef, 0x43, 0x4b, 0x0d, 0x13, 0x55, 0x69, 0x50, 0x1f, 0x33, 0xc6, 0x42, 0xae, 0xc2,
	0x46, 0x2d, 0xa9, 0x62, 0x99, 0x4a, 0xb2, 0x0d, 0xc1, 0x91, 0x88, 0x71, 0x64, 0x66, 0x89, 0xaf,
	0x4b, 0x57, 0x9f, 0x64, 0x1f, 0x06, 0x5f, 0x67, 0xa9, 0x08, 0xe7, 0x8f, 0x99, 0x0c, 0xe7, 0xa1,
	0x0c, 0x55, 0x83, 0x8e, 0x4f, 0x25, 0x33, 0x3b, 0xa1, 0x49, 0x8d, 0x50, 0xdd, 0x28, 0x8d, 0xfa,
	0x46, 0xf9, 0xde, 0x87, 0x9e, 0x09, 0x33, 0x3b, 0x59, 0xf2, 0xd7, 0x6a, 0x3b, 0xa8, 0x58, 0x76,
	0x09, 0xea, 0xef, 0xca, 0xfe, 0x6a, 0xd4, 0xf6, 0x97, 0x9b, 0x86, 0x41, 0x65, 0x1a, 0xde, 0x56,
	0xcf, 0xdc, 0x64, 0x65, 0xb1, 0xbd, 0x6a, 0x2b, 0xae, 0xa6, 0x7c, 0xe0, 0xd1, 0xd2, 0xf1, 0xe1,
	0x16, 0x6c, 0x9a, 0xbc, 0x52, 0x9d, 0x8a, 0xf3, 0x21, 0xf7, 0x5c, 0xa1, 0x94, 0x15, 0x99, 0xe0,
	0x05, 0xbb, 0x3c, 0x4e, 0x64, 0x00, 0xeb, 0x2f, 0x43, 0x19, 0x9d, 0x58, 0x84, 0x09, 0xc2, 0x68,
	0x3f, 0x29, 0x32, 0xa3, 0x32, 0xd1, 0xc8, 0x08, 0x06, 0x33, 0xc1, 0x39, 0x8b, 0xa4, 0xf3, 0x7a,
	0x02, 0xc3, 0x52, 0x63, 0xaf, 0xdc, 0x82, 0x76, 0xc1, 0xa2, 0x9c, 0x49, 0xdb, 0x19, 0x2b, 0xe1,
	0x07, 0xd0, 0x7e, 0xb3, 0x14, 0xb9, 0xee, 0xcc, 0x39, 0x64, 0xad, 0x89, 0x0c, 0xa1, 0x6f, 0x96,
	0xb1, 0xbb, 0xe0, 0x18, 0x06, 0x4e, 0x61, 0xe3, 0xbb, 0x35, 0xe4, 0xff, 0xd5, 0x1a, 0xfa, 0x14,
	0x7a, 0x67, 0xff, 0x91, 0x38, 0x1e, 0x55, 0x67, 0x3e, 0x5d, 0xf5, 0x20, 0x89, 0x9b, 0x4c, 0xef,
	0xc4, 0xee, 0xc6, 0x65, 0x26, 0xcc, 0x5d, 0x18, 0xb8, 0xab, 0x6c, 0x39, 0x1f, 0x96, 0xcb, 0xc9,
	0xbf, 0x60, 0x39, 0x95, 0xab, 0xe9, 0x0a, 0x0c, 0x9f, 0x9f, 0x2c, 0xe5, 0x5c, 0x7c, 0xc3, 0x57,
	0x10, 0x3a, 0x53, 0x59, 0x84, 0x86, 0xd0, 0x37, 0xb3, 0xca, 0x39, 0x29, 0xc8, 0xac, 0xc2, 0xba,
	0xdc, 0x87, 0xe1, 0x19, 0xb0, 0xa6, 0xde, 0x7f, 0xb0, 0x6b, 0xa6, 0x7f, 0xf8, 0xd0, 0xfe, 0x4a,
	0x83, 0x85, 0x77, 0xa1, 0x6d, 0xe8, 0x86, 0x58, 0xe1, 0xac, 0x26, 0xe5, 0x4e, 0x95, 0xc7, 0xe5,
	0xf5, 0xde, 0xc4, 0xc7, 0x9b, 0xd0, 0xd2, 0x5c, 0x43, 0x37, 0x1e, 0x57, 0x99, 0xb7, 0x53, 0xbb,
	0x9b, 0x78, 0x37, 0x7d, 0xbc, 0x0f, 0x5d, 0x97, 0x34, 0x6e, 0xb9, 0x0e, 0x55, 0xab, 0xd8, 0xd9,
	0x3e, 0xa7, 0x77, 0x57, 0xe2, 0xac, 0x9c, 0xcf, 0xff, 0xbb, 0x68, 0xc7, 0xb8, 0x08, 0x3b, 0x17,
	0x1b, 0xf5, 0x74, 0xf1, 0xa6, 0x3f, 0x36, 0xa0, 0xf5, 0x40, 0xd9, 0xf1, 0x9e, 0xda, 0x13, 0x9a,
	0xf5, 0xe8, 0xaa, 0xac, 0xbe, 0x8b, 0x9d, 0xad, 0xba, 0xba, 0x4c, 0xe5, 0x33, 0x68, 0x1e, 0xf2,
	0x57, 0x02, 0x1d, 0x51, 0x2a, 0x74, 0x2f, 0x9b, 0x56, 0xe5, 0x3c, 0xf1, 0x54, 0xaf, 0x6d, 0x05,
	0x55, 0x86, 0xd5, 0x0f, 0x56, 0xd9, 0x65, 0x0e, 0x1a, 0x02, 0x94, 0x07, 0x2b, 0x04, 0x29, 0x0f,
	0xd6, 0x58, 0xe2, 0xa9, 0x96, 0x3b, 0x7a, 0x95, 0x2d, 0xaf, 0x51, 0xb0, 0x6c, 0xf9, 0x39, 0x1e,
	0x7a, 0xd3, 0x43, 0xe8, 0x3e, 0x3d, 0x2e, 0x58, 0xfe, 0x96, 0xe5, 0xef, 0x88, 0xde, 0x71, 0x5b,
	0xff, 0x20, 0xb9, 0xfd, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6f, 0xe3, 0x12, 0x3d, 0x9f, 0x0c,
	0x00, 0x00,
}
