// Package certificatecache provides functionality for managing
// the certificate infrastructure.
package certificatecache

import (
	"crypto/x509"
	"crypto/x509/pkix"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/james-lawrence/bw"
	"github.com/james-lawrence/bw/internal/envx"
	"github.com/james-lawrence/bw/internal/errorsx"
	"github.com/james-lawrence/bw/internal/timex"
	"github.com/james-lawrence/bw/internal/tlsx"
	"github.com/pkg/errors"
)

const (
	// DefaultTLSCertCA default name for the certificate authority certificate.
	DefaultTLSCertCA = "tlsca.cert"
	// DefaultTLSGeneratedCAProto name of the protobuffer encoded CA cert, fingerprint file.
	DefaultTLSGeneratedCAProto = "tlsca.gen.proto"
	// DefaultTLSGeneratedCACert name of the tls ca generated by the cluster for generating
	// client certificates.
	DefaultTLSGeneratedCACert = "tlsca.gen.cert"
	// DefaultTLSKeyClient ...
	DefaultTLSKeyClient = "tlsclient.key"
	// DefaultTLSCertClient ...
	DefaultTLSCertClient = "tlsclient.cert"
	// DefaultTLSKeyServer ...
	DefaultTLSKeyServer = "tlsserver.key"
	// DefaultTLSCertServer used to bootstrap the servers
	DefaultTLSCertServer = "tlsserver.cert"
	// DefaultTLSSelfSignedCertServer used to bootstrap the servers
	DefaultTLSSelfSignedCertServer = "tlsserver.self.signed.cert"
	// DefaultDirTLSAuthority ...
	DefaultDirTLSAuthority = "authorities"
	// DefaultACMEKey default filename for the acme protocol account key.
	DefaultACMEKey = "acme.account.pem"
)

const (
	// ModeDisabled disable certificate refresh.
	ModeDisabled = "disabled"
	// ModeVault refresh certificates using vault's PKI
	ModeVault = "vault"
)

// NewRefreshClient default tls credentials refresh strategy for agents.
func NewRefreshClient(dir string, insecure bool) *Notary {
	return &Notary{CertificateDir: dir, Insecure: insecure}
}

// NewRefreshAgent default tls credentials refresh strategy for agents.
func NewRefreshAgent(dir string, a challenger) *ACME {
	x := NewACME(dir, a)
	return &x
}

// AutomaticTLSAgent generate a self signed certificate if necessary, this allows the agents
// to communicate with temporary credentials while acme is bootstrapping.
func AutomaticTLSAgent(seed []byte, domain, dir string) (err error) {
	_, err = RefreshExpired(filepath.Join(dir, DefaultTLSCertServer), time.Now(), selfsigned{
		seed:           seed,
		domain:         domain,
		credentialsDir: dir,
	})

	return err
}

// FromConfig will automatically refresh credentials in the provided directory
// based on the mode and the configuration file.
func FromConfig(dir, mode, configfile string, futureoffset time.Duration, fallback refresher) (err error) {
	log.Println("tls credentials mode", mode)
	switch mode {
	case ModeDisabled:
		return RefreshAutomatic(dir, futureoffset, Noop{})
	case ModeVault:
		v := Vault{
			DefaultTokenFile: VaultDefaultTokenPath(),
			CertificateDir:   dir,
		}

		if err = bw.ExpandAndDecodeFile(configfile, &v); err != nil {
			return err
		}

		if strings.TrimSpace(v.CommonName) == "" {
			return errors.New("server name cannot be blank for vault, please set servername in the configuration")
		}

		if strings.TrimSpace(v.Path) == "" {
			return errors.New("vault PKI path cannot be blank, please set VaultPKIPath in the configuration")
		}

		return RefreshAutomatic(dir, futureoffset, v)
	default:
		if err = bw.ExpandAndDecodeFile(configfile, fallback); err != nil {
			return err
		}

		return RefreshAutomatic(dir, futureoffset, fallback)
	}
}

// used to refresh credentials.
type refresher interface {
	Refresh() error
}

// Noop refresh which does nothing
type Noop struct{}

// Refresh implement refresher interface.
func (t Noop) Refresh() error {
	return nil
}

// RefreshAutomatic will automatically refresh credentials in the background.
// error is returned if something goes wrong prior to starting the goroutine.
// once the goroutine is started it will return nil.
func RefreshAutomatic(dir string, futureoffset time.Duration, r refresher) (err error) {
	var (
		due time.Duration
	)
	certpath := bw.LocateFirstInDir(dir, DefaultTLSCertServer, DefaultTLSCertClient)

	if due, err = RefreshExpired(certpath, time.Now().UTC().Add(futureoffset), r); err != nil {
		return err
	}

	go func() {
		for {
			if envx.Boolean(false, bw.EnvLogsTLS, bw.EnvLogsVerbose) {
				log.Println("next refresh", due)
			}
			time.Sleep(due)

			if due, err = RefreshExpired(certpath, time.Now().UTC().Add(futureoffset), r); err != nil {
				errorsx.Log(errors.Wrap(err, "failed to refresh credentials"))
			}
		}
	}()

	return nil
}

// RefreshExpired refreshes certificates if the certificate at the provided path
// has an expiration after the provided time.
func RefreshExpired(certpath string, t time.Time, r refresher) (_ time.Duration, err error) {
	const minFrequency = time.Minute // no reason to attempt more frequently than 1 minute
	var (
		expiration time.Time
		due        = minFrequency
	)

	// first ensure directory exists.
	if err = os.MkdirAll(filepath.Dir(certpath), 0700); err != nil {
		return due, errors.WithStack(err)
	}

	// force refresh a new certificate if no certificate exists.
	// set the next refresh to be a minute from now, forces a hopefully successful
	// iteration where it'll use the certicates actual expiration to compute the next iteration.
	if _, err = os.Stat(certpath); os.IsNotExist(err) {
		return due, r.Refresh()
	}

	if expiration, err = expiredCert(certpath); err != nil {
		return due, err
	}

	// check once a day, unless the expiration / 4 is sooner.
	due = timex.DurationMin(24*time.Hour, expiration.Sub(t)/4)

	// no reason to refresh more frequently than 30s, even when we have an expired certificate.
	due = timex.DurationMax(minFrequency, due)
	refreshNeeded := t.Equal(expiration) || t.After(expiration)
	if envx.Boolean(false, bw.EnvLogsTLS, bw.EnvLogsVerbose) {
		log.Println("certificate refresh check", expiration, "<=", t, "->", refreshNeeded)
	}

	if refreshNeeded {
		return due, r.Refresh()
	}

	return due, nil
}

// returns the expiration of the certificate at the given path.
func expiredCert(path string) (expiration time.Time, err error) {
	var (
		data []byte
		cert *x509.Certificate
	)

	if data, err = os.ReadFile(path); err != nil {
		log.Println("failed to read certificate", err)
		return expiration, errors.WithStack(err)
	}

	if cert, err = tlsx.DecodePEMCertificate(data); err != nil {
		return expiration, errors.Wrapf(err, "decoding certificate failed: %s", path)
	}

	if cert == nil {
		return expiration, fmt.Errorf("decoding certificate failed: %s", path)
	}

	if envx.Boolean(false, bw.EnvLogsTLS, bw.EnvLogsVerbose) {
		log.Println("cert:", path)
		log.Println("cert expires at", cert.NotAfter)
		log.Println("cert not valid before", cert.NotBefore)
	}

	return cert.NotAfter, nil
}

// ServerTLSOptions default options for server certificates
func ServerTLSOptions(hosts ...string) []tlsx.X509Option {
	return []tlsx.X509Option{
		tlsx.X509OptionUsage(x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageKeyAgreement),
		tlsx.X509OptionUsageExt(x509.ExtKeyUsageAny),
		tlsx.X509OptionHosts(hosts...),
		tlsx.X509OptionSubject(pkix.Name{
			CommonName: "server",
		}),
	}
}

// CAKeyPath generate CAKeyPath for agents.
func CAKeyPath(dir, name string) string {
	return filepath.Join(dir, name)
}

// CACertPath generate CACertPath for agents.
func CACertPath(dir, name string) string {
	return filepath.Join(dir, DefaultDirTLSAuthority, name)
}
